/*
 * drvNvMemory.c
 *
 *  Created on: 15.10.2019
 *      Author: ChrLin00
 *
 *      alternative to the crap eeprom emulator from st
 *      Writing to flash is not protected! (if Power is removed during write, the user data in flash is corruted!)
 *      When supporting a multicolor display, we need up to 3kB of Flash to save the Picture-Data -> this needs to support more than 1 Page!
 *      Only 16-bit read/write and addressing
 */
#include "drvNvMemory.h"
#include "stm32f0xx.h"


#define NVMEM_PAGE_COUNT		2	//if you change that, don't forget to change the length of the flash-section in the linker-script!
#define NVMEM_FLASH_PAGESIZE	1024
#define NVMEM_FLASH_BASE		(0x08008000 - NVMEM_PAGE_COUNT*NVMEM_FLASH_PAGESIZE)
#define NVMEM_AD_TOP			(NVMEM_FLASH_PAGESIZE*NVMEM_PAGE_COUNT/2)-1

#define READ16(address) ((uint16_t)(*(uint16_t*)(address)))

uint16_t NvMem_RamBuffer[NVMEM_PAGE_COUNT*512];
bool NvMem_Writable;



/**
 * loads user data from flash into memory for easy access and change in the application
 */
void NvMem_init()
{
	for(uint16_t ad = 0; ad<=NVMEM_AD_TOP; ad++)
	{
		NvMem_RamBuffer[ad]=READ16(NVMEM_FLASH_BASE+2*ad);
	}
	NvMem_Writable = true;
}

/**
 * Reads 16 bit form the user space in flash
 * address: 16-bit address (512 addresses per used flash page)
 */
uint16_t NvMem_read(uint16_t address)
{
	if(address > NVMEM_AD_TOP)
	{
		return NVMEM_ERR_OUTOFRANGE;
	}
	return NvMem_RamBuffer[address];
}


/**
 * Writes 16 bit to the user space in flash
 * address: 16-bit address (512 addresses per used flash page)
 * data: data to write
 * returns: errorcode
 */
uint8_t NvMem_write(uint16_t address, uint16_t data)
{
	if(address > NVMEM_AD_TOP)
	{
		return ERR_NVMEM_OUTOFRANGE;
	}
	if(!NvMem_Writable)
	{
		return ERR_NVMEM_ALREADYWRITTEN;
	}
	NvMem_RamBuffer[address] = data;
}

/**
 * This is the only place we're writing to flash
 * This can only be done once for every start of the device!
 * The erasing and writing takes some time, during this time the device is not responsive and must not be unpowered!
 */
uint8_t NvMem_SaveToFlash()
{
	//enable flash-if clock
	RCC->AHBENR |= RCC_AHBENR_FLITFEN;

	//wait till flash is ready
	while((FLASH->SR & FLASH_SR_BSY)!=0)
	{

	}
	//unlock flash
	if((FLASH->CR & FLASH_CR_LOCK)!=0)
	{
		FLASH->KEYR = FLASH_FKEY1;
		FLASH->KEYR = FLASH_FKEY2;
	}
	//erase all pages assigned to the nvmem
	FLASH->CR |= FLASH_CR_PER;
	for(uint8_t i = 0; i < NVMEM_PAGE_COUNT; i++)
	{
		FLASH->AR =  NVMEM_FLASH_BASE + i* NVMEM_FLASH_PAGESIZE;
		FLASH->CR |= FLASH_CR_STRT;
		while((FLASH->SR & FLASH_SR_BSY)!=0)
		{

		}
		if((FLASH->SR & FLASH_SR_EOP)!=0)
		{
			FLASH->SR = FLASH_SR_EOP;
		}else
		{
			return ERR_NVMEM_ERASEFAIL;
		}
	}
	FLASH->CR &=~FLASH_CR_PER;
	//write data
	while((FLASH->SR & FLASH_SR_BSY)!=0)
	{

	}
	for(uint16_t ad = 0; ad< NVMEM_AD_TOP; ad++)
	{
		FLASH->CR |= FLASH_CR_PG;
		*(uint16_t *)(NVMEM_FLASH_BASE+2*ad) = NvMem_RamBuffer[ad];
	}


	NvMem_Writable = false;
}


