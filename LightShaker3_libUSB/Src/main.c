/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialised, but the project is compiling for an FPU. Please initialise the FPU before use."
#endif

/* Includes */
#include "main.h"
#include "stm32f0xx_rcc.h"


//#include "winusb_loop.h"
//#include "configConsole.h"
#include "drvPower.h"
#include "stm32f0xx_misc.h"
#include <drvNeopixels.h>
#include "AppMgmt.h"

/* Private typedef */

/* Private define  */

/* Private macro */

/* Private variables */

/* Private function prototypes */

/* Private functions */

/* Global variables */
uint8_t timer_ms = 10;
uint8_t timer_10ms = 10;
volatile uint8_t  timerFlags = 0;
#define TIMER_FLAG_1MS		(1<<0)
#define TIMER_FLAG_10MS		(1<<1)
#define TIMER_FLAG_100MS	(1<<2)
#define TIMER_FLAG_APP		(1<<3)

volatile uint32_t appTimer = 100;
volatile uint32_t delayTimer;




/**
**===========================================================================
**
**  Abstract: SysTick interrupt handler - triggered every ms
**	Sets the Timer Flags
**	TIMER_FLAG_1MS every ms
**	TIMER_FLAG_10MS every 10ms
**	TIMER_FLAG_100MS every 100ms
**	clearing of the flag has to be done in the application code!
**
**===========================================================================
*/
void SysTick_Handler(void)
{
	if(delayTimer)
	{
		delayTimer--;
	}
	timer_ms--;
	timerFlags |= TIMER_FLAG_1MS;

	//10ms timebase
	if(!timer_ms)
	{
		timerFlags |= TIMER_FLAG_10MS;
		timer_ms = 10;
		timer_10ms--;
	}
	//100ms timebase
	if(!timer_10ms)
	{
		timerFlags |= TIMER_FLAG_100MS;
		timer_10ms = 10;
	}
	//application timer
	if(appTimer)
	{
		appTimer--;
	}
	else
	{
		timerFlags |= TIMER_FLAG_APP;
		appTimer = AppMgmt_Timebase;
	}
}

/**
 * blocking delay loop
 * @param ticks: number of ticks (ms) to wait
 */
void delay(uint32_t ticks)
{
	delayTimer = ticks;
	while(delayTimer > 0);
}

int main(void)
{
	SystemInit();
	SystemCoreClockUpdate();
	//the systick timer runs with 6MHz
	//config the timer for 1ms interval
	SysTick_Config(SystemCoreClock / 8 / 1000);
	//the systick_config just set the priority of the systick to 15  or so - very low!
	//set it back to 0
	NVIC_SetPriority(SysTick_IRQn,0);
	SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8);

	power_init();
	Neopixels_init();	//this includes a quick led-test

	if(power_UsbPresent()) {
		//we are attached to a USB-Port!
		//USB_Init();
//		winusb_init_usbd();
//		usb_device_connect();
//		consoleInit();
	}
	//init application (run once)
	AppMgmt_AppInit();

	while(1)
	{

//		if(power_UsbPresent()){
//			USB_Handler();
//		}

		//run application (called continously until button is held long enough to switch to another one or power is switched off)
		if(timerFlags & TIMER_FLAG_APP)
		{
			timerFlags &= ~TIMER_FLAG_APP;
			AppMgmt_AppExec();
		}
		if(timerFlags & TIMER_FLAG_100MS)
		{
			timerFlags &= ~TIMER_FLAG_100MS;
			power_exec();

			if(power_flags & POWER_FLAG_SW_HOLD)
			{
				if(power_buttonHoldTime >= 5)
				{
					AppMgmt_CycleApps();
					power_buttonHoldTime = 0;
				}
				//only if the swich is released after holding it for at least 0.5s
				if(power_flags & POWER_FLAG_SW_RELEASE)
				{
					power_flags &= ~POWER_FLAG_SW_HOLD;
					power_flags &= ~POWER_FLAG_SW_RELEASE;
					AppMgmt_LoadApp();
				}
			}
		}

	}
	return 0;
}
